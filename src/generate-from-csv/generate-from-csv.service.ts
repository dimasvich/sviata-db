import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import * as csv from 'csv-parser';
import { Model } from 'mongoose';
import OpenAI from 'openai';
import { Sviato, SviatoDocument } from 'src/crud/schema/sviato.schema';
import { Readable } from 'stream';
import * as cheerio from 'cheerio';

@Injectable()
export class GenerateFromCsvService {
  private openai: OpenAI;

  constructor(
    @InjectModel(Sviato.name) private sviatoModel: Model<SviatoDocument>,
  ) {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
  }

  private async parseCsvFile(file: Express.Multer.File): Promise<
    {
      date: string;
      type: string;
      tags: string[];
      name: string;
    }[]
  > {
    return new Promise((resolve, reject) => {
      const results: {
        date: string;
        type: string;
        tags: string[];
        name: string;
      }[] = [];

      const stream = Readable.from(file.buffer);

      stream
        .pipe(csv({ separator: ',' }))
        .on('data', (row) => {
          const parsed = {
            date: row['–¥–∞—Ç–∞']?.trim(),
            type: row['—Ç–∏–ø —Å–≤—è—Ç–∞']?.trim(),
            tags: row['—Å–ø–∏—Å–æ–∫ —Ç–µ–≥—ñ–≤']
              ? row['—Å–ø–∏—Å–æ–∫ —Ç–µ–≥—ñ–≤']
                  .split(',')
                  .map((t: string) => t.trim())
                  .filter(Boolean)
              : [],
            name: row['–Ω–∞–∑–≤–∞ —Å–≤—è—Ç–∞']?.trim(),
          };
          results.push(parsed);
        })
        .on('end', () => resolve(results))
        .on('error', (error) => reject(error));
    });
  }

  private async parseUploadedFile(
    data: {
      date: string;
      type: string;
      tags: string[];
      name: string;
    }[],
  ) {
    const prompts = data.map(
      (item) => `PROMPT:
        –°—Ç–≤–æ—Ä–∏ –∫–æ—Ä–æ—Ç–∫—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ–π–Ω—É —Å—Ç–∞—Ç—Ç—é –ø—Ä–æ —Å–≤—è—Ç–æ {${item.name}}, —è–∫–µ –≤—ñ–¥–∑–Ω–∞—á–∞—é—Ç—å {${item.date}}, —â–æ –Ω–∞–ª–µ–∂–∏—Ç—å –¥–æ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó {${item.type}}, 
        –∞ —Ç–∞–∫–æ–∂ –º–∞—î –Ω–∞—Å—Ç—É–ø–Ω–∏–π —Å–ø–∏—Å–æ–∫ —Ç–µ–≥—ñ–≤: {${item.tags.map((t) => t)}}.

        –ú–µ—Ç–∞: –¥–∞—Ç–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É –ª–∞–∫–æ–Ω—ñ—á–Ω–µ, –∞–ª–µ –∑–º—ñ—Å—Ç–æ–≤–Ω–µ –ø–æ—è—Å–Ω–µ–Ω–Ω—è –ø—Ä–æ —Ü–µ —Å–≤—è—Ç–æ, —â–æ–± –≤—ñ–Ω –æ–¥—Ä–∞–∑—É –∑—Ä–æ–∑—É–º—ñ–≤ –π–æ–≥–æ —Å—É—Ç—å, —ñ—Å—Ç–æ—Ä—ñ—é —ñ –∑–Ω–∞—á–µ–Ω–Ω—è.

        –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å—Ç–∞—Ç—Ç—ñ:
        H1: –æ—Ñ—ñ—Ü—ñ–π–Ω–∞ –Ω–∞–∑–≤–∞ —Å–≤—è—Ç–∞ (–±–µ–∑ –¥–∞—Ç–∏).
        –≤—Å—Ç—É–ø–Ω–∏–π —Ç–µ–∫—Å—Ç. –≤ –ø–µ—Ä—à–æ–º—É —Ä–µ—á–µ–Ω–Ω—ñ –æ–¥—Ä–∞–∑—É –¥–∞–≤–∞—Ç–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥—å/–ø–æ—è—Å–Ω–µ–Ω–Ω—è –Ω–∞/–ø—Ä–æ –ù1

        H2: ¬´–ü—Ä–æ ${item.name}¬ª
        1‚Äì2 —Ä–µ—á–µ–Ω–Ω—è –∑ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ—é –¥–∞—Ç–æ—é —Å–≤—è—Ç–∫—É–≤–∞–Ω–Ω—è.
        2‚Äì3 —Ä–µ—á–µ–Ω–Ω—è –∑ –∫–æ—Ä–æ—Ç–∫–∏–º –æ–ø–∏—Å–æ–º –ø–æ—Ö–æ–¥–∂–µ–Ω–Ω—è.
        2‚Äì4 —Ä–µ—á–µ–Ω–Ω—è –ø—Ä–æ —Ç—Ä–∞–¥–∏—Ü—ñ—ó —Å–≤—è—Ç–∫—É–≤–∞–Ω–Ω—è, —Å–∏–º–≤–æ–ª—ñ–∫—É —Ç–∞ –∑–Ω–∞—á–µ–Ω–Ω—è.
        1‚Äì2 —Ä–µ—á–µ–Ω–Ω—è –∑ —Ü—ñ–∫–∞–≤–∏–º–∏ —Ñ–∞–∫—Ç–∞–º–∏, —è–∫—â–æ —î.

        –ù–∞–ø—Ä–∏–∫—ñ–Ω—Ü—ñ –¥–æ–¥–∞–π:
        <meta name="title" content="(55‚Äì65 —Å–∏–º–≤–æ–ª—ñ–≤)">
        <meta name="description" content="(165‚Äì200 —Å–∏–º–≤–æ–ª—ñ–≤)">
        `,
    );
    return prompts;
  }

  private async generateHtmlForPrompt(prompt: string): Promise<string> {
    const response = await this.openai.chat.completions.create({
      model: 'gpt-5',
      messages: [
        {
          role: 'system',
          content:
            '–í–∏ –µ–∫—Å–ø–µ—Ä—Ç –∑ –Ω–∞–ø–∏—Å–∞–Ω–Ω—è —Å—Ç–∞—Ç–µ–π —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é, —è–∫–∏–π –≥–µ–Ω–µ—Ä—É—î —Ç–µ–∫—Å—Ç —É —Ñ–æ—Ä–º–∞—Ç—ñ HTML.',
        },
        { role: 'user', content: prompt },
      ],
    });

    return response.choices[0]?.message?.content?.trim() || '';
  }

  public async uploadGenerateAndSave(file: Express.Multer.File) {
    try {
      const data = await this.parseCsvFile(file);
      const prompts = await this.parseUploadedFile(data);

      const results = await Promise.all(
        prompts.map(async (prompt, index) => {
          try {
            console.log(
              `üîπ –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è ${index + 1}/${data.length}: ${data[index].name}`,
            );

            const html = await this.generateHtmlForPrompt(prompt);

            if (!html) {
              console.warn(`‚ö†Ô∏è –ü–æ—Ä–æ–∂–Ω—ñ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è: ${data[index].name}`);
              return { name: data[index].name, success: false };
            }

            const $ = cheerio.load(html);
            const h1Text = $('h1').first().text().trim();
            const metaTitle = $('meta[name="title"]').attr('content') || '';
            const metaDescription =
              $('meta[name="description"]').attr('content') || '';

            await this.sviatoModel.create({
              tags: data[index].tags,
              date: data[index].date,
              type: data[index].type,
              name: h1Text || data[index].name,
              title: metaTitle,
              description: metaDescription,
              seoText: html,
            });

            console.log(`‚úÖ –ó–±–µ—Ä–µ–∂–µ–Ω–æ: ${data[index].name}`);
            return { name: data[index].name, success: true };
          } catch (err) {
            console.error(
              `‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ ${data[index].name}:`,
              err.message,
            );
            return {
              name: data[index].name,
              success: false,
              error: err.message,
            };
          }
        }),
      );

      const successCount = results.filter((r) => r.success).length;
      const failedCount = results.filter((r) => !r.success).length;

      console.log(
        `üèÅ –ó–∞–≤–µ—Ä—à–µ–Ω–æ. –£—Å–ø—ñ—à–Ω–æ: ${successCount}, –ü–æ–º–∏–ª–æ–∫: ${failedCount}`,
      );

      return { total: data.length, successCount, failedCount, results };
    } catch (error) {
      console.error('üí• Error in uploadGenerateAndSave:', error);
      throw error;
    }
  }
}
